<!-- https://learn.microsoft.com/en-us/azure/ai-foundry/openai/how-to/realtime-audio-webrtc#supported-models -->

<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Azure OpenAI Realtime Session</title>
</head>

<body>
  <h1>Azure OpenAI Realtime Session</h1>
  <p>WARNING: Don't use this code sample in production with the API key hardcoded. Use a protected backend service to
    call the sessions API and generate the ephemeral key. Then return the ephemeral key to the client.</p>
  <button onclick="StartSession()">Start Session</button>

  <!-- Log container for API messages -->
  <div id="logContainer"></div>

  <script>
    const WEBRTC_URL = "https://eastus2.realtimeapi-preview.ai.azure.com/v1/realtimertc";
    const DEPLOYMENT = "gpt-4o-realtime-preview";
    const VOICE = "ash";

    async function StartSession() {
      try {
        // This would normally come from your backend (DONâ€™T expose real keys!)
        const responseData = {
          session_id: "sess_CGhH1jddBFTsdbUd30oxS",
          ephemeral_key: "ek_68ca690b9af08191ae233c4d3589a893",
          expires_at: 1758102827,
          seconds_until_expiry: 7200,
          webrtc_url: "https://eastus2.realtimeapi-preview.ai.azure.com/v1/realtimertc",
          deployment: "gpt-4o-realtime-preview",
          api_version: "2025-04-01-preview",
          voice: "ash"
        };

        const sessionId = responseData.session_id;
        const ephemeralKey = responseData.ephemeral_key;
        const webrtcUrl = responseData.webrtc_url;

        logMessage("Ephemeral Key Received: " + "***");
        logMessage("WebRTC Session Id = " + sessionId);

        // Use the webrtc_url provided in the response, not the hardcoded one
        await init(ephemeralKey, webrtcUrl);

      } catch (error) {
        console.error("Error starting session:", error);
        logMessage("Error starting session: " + error.message);
      }
    }

    async function init(ephemeralKey, webrtcUrl) {
      let peerConnection = new RTCPeerConnection();

      const audioElement = document.createElement('audio');
      audioElement.autoplay = true;
      document.body.appendChild(audioElement);

      peerConnection.ontrack = (event) => {
        audioElement.srcObject = event.streams[0];
      };

      const clientMedia = await navigator.mediaDevices.getUserMedia({ audio: true });
      const audioTrack = clientMedia.getAudioTracks()[0];
      peerConnection.addTrack(audioTrack);

      const dataChannel = peerConnection.createDataChannel('realtime-channel');
      dataChannel.addEventListener('open', () => {
        logMessage('Data channel is open');
      });
      dataChannel.addEventListener('message', (event) => {
        logMessage("Received server event: " + event.data);
      });

      // SDP Offer
      const offer = await peerConnection.createOffer();
      await peerConnection.setLocalDescription(offer);

      const sdpResponse = await fetch(`${webrtcUrl}?model=${DEPLOYMENT}`, {
        method: "POST",
        body: offer.sdp,
        headers: {
          Authorization: `Bearer ${ephemeralKey}`,
          "Content-Type": "application/sdp",
        },
      });

      const answer = { type: "answer", sdp: await sdpResponse.text() };
      await peerConnection.setRemoteDescription(answer);

      logMessage("Session started successfully.");
    }

    function logMessage(message) {
      const logContainer = document.getElementById("logContainer");
      const p = document.createElement("p");
      p.textContent = message;
      logContainer.appendChild(p);
    }
  </script>

</body>

</html>